<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <title>WebXR AR Creature Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { ARButton } from 'https://unpkg.com/three@0.152.2/examples/jsm/webxr/ARButton.js';

let camera, scene, renderer;
let controller;
let reticle;
let creature;
let hitTestSource = null;
let hitTestSourceRequested = false;

init();

function init() {
    // Szene und Kamera
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // AR Button
    document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

    // Licht
    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
    scene.add(light);

    // Reticle für Platzierung
    reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Erstelle Kreatur aus Primitiven
    creature = new THREE.Group();
    // Körper
    const bodyGeom = new THREE.SphereGeometry(0.1, 16, 16);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffcc00 });
    const body = new THREE.Mesh(bodyGeom, bodyMat);
    creature.add(body);
    // Kopf
    const headGeom = new THREE.SphereGeometry(0.06, 16, 16);
    const headMat = new THREE.MeshStandardMaterial({ color: 0xffee88 });
    const head = new THREE.Mesh(headGeom, headMat);
    head.position.set(0, 0.14, 0);
    creature.add(head);
    // Augen
    const eyeGeom = new THREE.SphereGeometry(0.01, 8, 8);
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
    const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
    leftEye.position.set(-0.02, 0.16, 0.06);
    const rightEye = leftEye.clone();
    rightEye.position.x = 0.02;
    creature.add(leftEye, rightEye);
    // Füße
    const footGeom = new THREE.CylinderGeometry(0.02, 0.02, 0.04, 8);
    const footMat = new THREE.MeshStandardMaterial({ color: 0x884400 });
    const leftFoot = new THREE.Mesh(footGeom, footMat);
    leftFoot.position.set(-0.04, -0.1, 0);
    const rightFoot = leftFoot.clone();
    rightFoot.position.x = 0.04;
    creature.add(leftFoot, rightFoot);

    creature.visible = false;
    scene.add(creature);

    // Controller für Platzierungs-Event
    controller = renderer.xr.getController(0);
    controller.addEventListener('select', onSelect);
    scene.add(controller);

    window.addEventListener('resize', onWindowResize);

    renderer.setAnimationLoop(render);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function onSelect() {
    if (reticle.visible) {
        creature.position.setFromMatrixPosition(reticle.matrix);
        creature.visible = true;
    }
}

function render(timestamp, frame) {
    if (frame) {
        const session = renderer.xr.getSession();
        const referenceSpace = renderer.xr.getReferenceSpace();

        if (!hitTestSourceRequested) {
            session.requestReferenceSpace('viewer').then((refSpace) => {
                session.requestHitTestSource({ space: refSpace }).then((source) => {
                    hitTestSource = source;
                });
            });
            session.addEventListener('end', () => {
                hitTestSourceRequested = false;
                hitTestSource = null;
            });
            hitTestSourceRequested = true;
        }

        if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
                const hit = hitTestResults[0];
                const pose = hit.getPose(referenceSpace);
                reticle.visible = true;
                reticle.matrix.fromArray(pose.transform.matrix);
            } else {
                reticle.visible = false;
            }
        }
    }

    // Leichte Oszillation
    if (creature.visible) {
        const t = timestamp / 1000;
        creature.position.x += Math.sin(t) * 0.001;
    }

    renderer.render(scene, camera);
}
</script>
</body>
</html>
