<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>WebXR AR – Pokémon Capture (Audio + Eye Fix)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:transparent; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    #ui { position:fixed; inset:0; pointer-events:none; display:flex; align-items:flex-end; justify-content:center; padding:16px; }
    .hint { pointer-events:auto; background:rgba(0,0,0,.55); color:#fff; padding:10px 12px; border-radius:12px; font-size:14px; backdrop-filter: blur(6px); max-width:min(90vw,720px); }
    .actions { position:fixed; top:12px; right:12px; display:flex; gap:8px; pointer-events:auto; }
    .btn { border:0; border-radius:10px; padding:8px 12px; font-size:14px; cursor:pointer; background:#111; color:#fff; opacity:.9; }
    .btn:active { transform: translateY(1px); }
    .hidden { display:none !important; }
    .legend { position:fixed; left:12px; bottom:12px; font-size:12px; color:#fff; opacity:.75; pointer-events:auto; background:rgba(0,0,0,.45); padding:6px 8px; border-radius:8px; }
  </style>
</head>
<body>
  <div id="ui"><div id="hint" class="hint">Bewege das Headset/Smartphone, bis Flächen erkannt sind. <b>Controller 0: Select</b> platziert zufällig eine Figur. <b>Controller 1: Select</b> wirft die Poké-Kugel.</div></div>
  <div class="actions hidden" id="actions">
    <button class="btn" id="reposition">Neu platzieren</button>
    <button class="btn" id="remove">Entfernen</button>
  </div>
  <div class="legend" id="legend">Gelbe Flächen = erkannte Ebenen (blenden nach kurzer Zeit aus)</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { ARButton } from 'https://unpkg.com/three@0.152.2/examples/jsm/webxr/ARButton.js';

let camera, scene, renderer;
let controller0, controller1;
let reticle;
let creature;
let creatureVariants = [];
let shadowPlane;
let hitTestSource = null;
let hitTestSourceRequested = false;
const planeMeshes = new Map();

let dirLight, hemiLight;
let xrLightProbe = null, xrGlBinding = null;
let allowPlaneDebug = true;
let lastPlaneSeenAt = 0;
let placingMode = true;
const tmpVec3 = new THREE.Vector3();
let lastTime = 0;

// Capture State
let isCaptured = false;
let pokeBall = null;
let captureState = null;
let captureT = 0;
let captureData = null;

// ---------- SFX (WebAudio) ----------
let actx = null;
function ensureAudio() {
  if (!actx) {
    actx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (actx.state === 'suspended') actx.resume();
}
function tone({freq=440, dur=0.12, type='sine', gain=0.08, attack=0.005, decay=0.04}) {
  if (!actx) return;
  const t0 = actx.currentTime;
  const osc = actx.createOscillator();
  const g  = actx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  g.gain.value = 0.0;
  g.gain.linearRampToValueAtTime(gain, t0 + attack);
  g.gain.linearRampToValueAtTime(0.0001, t0 + attack + decay + dur);
  osc.connect(g).connect(actx.destination);
  osc.start(t0);
  osc.stop(t0 + attack + decay + dur + 0.02);
}
const SFX = {
  place(){ tone({freq:660, type:'triangle', gain:0.09, attack:0.005, decay:0.05, dur:0.05}); },
  throw(){ tone({freq:380, type:'sawtooth', gain:0.05, attack:0.003, decay:0.03, dur:0.06}); tone({freq:760, type:'sawtooth', gain:0.03, attack:0.003, decay:0.06, dur:0.08}); },
  suck(){ tone({freq:880, type:'square', gain:0.06, attack:0.003, decay:0.12, dur:0.14}); },
  bounce(){ tone({freq:240, type:'triangle', gain:0.07, attack:0.003, decay:0.06, dur:0.06}); },
  jump(){ tone({freq:520, type:'square', gain:0.04, attack:0.003, decay:0.05, dur:0.05}); }
};

function lerpAngle(a, b, t) {
  let diff = ((b - a + Math.PI) % (Math.PI * 2)) - Math.PI;
  return a + diff * t;
}

init();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  const btn = ARButton.createButton(renderer, {
    requiredFeatures: ['hit-test', 'plane-detection'],
    optionalFeatures: ['dom-overlay','light-estimation'],
    domOverlay: { root: document.body }
  });
  document.body.appendChild(btn);

  // Lights
  hemiLight = new THREE.HemisphereLight(0xffffff, 0x666688, 0.9);
  scene.add(hemiLight);

  dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(0.5, 1.2, 0.5);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(1024,1024);
  dirLight.shadow.camera.near = 0.01;
  dirLight.shadow.camera.far = 5;
  dirLight.shadow.radius = 2;
  scene.add(dirLight);

  // Reticle
  reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.12, 0.18, 40).rotateX(-Math.PI / 2),
    new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent:true, opacity:0.9 })
  );
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);
  const inner = new THREE.Mesh(
    new THREE.CircleGeometry(0.12, 32).rotateX(-Math.PI/2),
    new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent:true, opacity:0.15 })
  );
  reticle.add(inner);

  // Variants
  const baseRed     = buildBaseRed();     baseRed.scale.setScalar(1.00);
  const pikaLike    = buildPikaLike();    pikaLike.scale.setScalar(0.85);
  const turtleLike  = buildTurtleLike();  turtleLike.scale.setScalar(0.95);
  const lizardLike  = buildLizardLike();  lizardLike.scale.setScalar(1.15);

  creatureVariants = [baseRed, pikaLike, turtleLike, lizardLike];
  for (const g of creatureVariants) {
    g.visible = false;
    g.userData.initialScale = g.scale.x;
    scene.add(g);
  }
  creature = baseRed;

  // Shadow receiver
  shadowPlane = new THREE.Mesh(
    new THREE.CircleGeometry(0.16, 32).rotateX(-Math.PI/2),
    new THREE.ShadowMaterial({ opacity: 0.35 })
  );
  shadowPlane.receiveShadow = true;
  shadowPlane.visible = false;
  scene.add(shadowPlane);

  // Controllers
  controller0 = renderer.xr.getController(0);
  controller0.addEventListener('selectstart', ensureAudio); // AudioContext öffnen
  controller0.addEventListener('select', onSelectPrimary);
  scene.add(controller0);

  controller1 = renderer.xr.getController(1);
  controller1.addEventListener('selectstart', ensureAudio);
  controller1.addEventListener('select', onSelectCapture);
  scene.add(controller1);

  renderer.xr.addEventListener('sessionstart', onSessionStart);
  window.addEventListener('resize', onWindowResize);

  // UI
  document.getElementById('reposition').onclick = () => { placingMode = true; showHint("Ziel anvisieren & Select drücken – zufällige Figur wird platziert."); };
  document.getElementById('remove').onclick = () => removeCreature();

  // Poké-Kugel
  pokeBall = buildPokeBall();
  pokeBall.visible = false;
  scene.add(pokeBall);

  renderer.setAnimationLoop(render);
}

function onSessionStart() {
  const session = renderer.xr.getSession();
  session.updateWorldTrackingState({ planeDetectionState: { enabled: true } });
  session.addEventListener('planeadded', onPlaneAdded);
  session.addEventListener('planeremoved', onPlaneRemoved);
  session.addEventListener('planeupdated', onPlaneUpdated);

  try {
    if (session.requestLightProbe) {
      xrGlBinding = new XRWebGLBinding(session, renderer.getContext());
      session.requestLightProbe({}).then(lp => xrLightProbe = lp).catch(()=>{ xrLightProbe = null; });
    }
  } catch { xrLightProbe = null; }

  showHint("Bewegen, bis Flächen erkannt sind. Controller 0: zufällige Figur platzieren. Controller 1: Poké-Kugel werfen.");
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ========================== CREATURES ========================== */
function withStandardAnimData(group, extras = {}) {
  const head = extras.head;
  const body = extras.body;
  group.userData = {
    ...extras,
    footBaseY: extras.footBaseY ?? 0.03,
    headBaseY: head ? head.position.y : 0,
    bodyBaseY: body ? body.position.y : 0.12,
    initialScale: group.scale.x,
    animationState: { breathPhase:0, blinkTimer:0, headBobPhase:0, tailWagPhase:0, jumpPhase:0, jumping:false, walkPhase:0 }
  };
  return group;
}

/* --------- Base (rot) ---------- */
function buildBaseRed() {
  const g = new THREE.Group();

  const body = new THREE.Mesh(new THREE.SphereGeometry(0.12, 20, 20),
    new THREE.MeshStandardMaterial({ color: 0xff6b6b, roughness:0.35, metalness:0.05 }));
  body.castShadow = true; body.position.y = 0.12;

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.08, 20, 20),
    new THREE.MeshStandardMaterial({ color: 0xff8e8e, roughness:0.25, metalness:0.1 }));
  head.castShadow = true; head.position.set(0,0.28,0);

  // Augen + Lider (sichtbar vor dem Kopf)
  const eyeGeom = new THREE.SphereGeometry(0.025, 12, 12);
  const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness:0.4, metalness:0.3 });
  eyeMat.depthWrite = false; // wichtig
  const eye1 = new THREE.Mesh(eyeGeom, eyeMat); eye1.position.set(-0.03, 0.30, 0.072); eye1.castShadow = false; eye1.renderOrder = 10;
  const eye2 = eye1.clone(); eye2.position.x = 0.03;

  const eyelidGeom = new THREE.SphereGeometry(0.026, 12, 6, 0, Math.PI*2, 0, Math.PI*0.5);
  const eyelidMat = new THREE.MeshStandardMaterial({ color: 0xff8e8e });
  eyelidMat.depthWrite = false;
  const eyelid1 = new THREE.Mesh(eyelidGeom, eyelidMat); eyelid1.position.copy(eye1.position); eyelid1.position.y += 0.01; eyelid1.scale.y = 0; eyelid1.renderOrder = 12;
  const eyelid2 = eyelid1.clone(); eyelid2.position.copy(eye2.position); eyelid2.position.y += 0.01;

  const nose = new THREE.Mesh(new THREE.ConeGeometry(0.015, 0.03, 8), new THREE.MeshStandardMaterial({ color: 0xff4757 }));
  nose.position.set(0,0.28,0.085); nose.rotation.x = Math.PI/2; nose.castShadow = true; nose.renderOrder = 11;

  const cheekGeom = new THREE.CircleGeometry(0.02, 16);
  const cheekMat = new THREE.MeshStandardMaterial({ color: 0xff3838, transparent:true, opacity:0.8 });
  cheekMat.depthWrite = false;
  const cheek1 = new THREE.Mesh(cheekGeom, cheekMat); cheek1.position.set(-0.06,0.26,0.062); cheek1.renderOrder = 11;
  const cheek2 = cheek1.clone(); cheek2.position.x = 0.06;

  const footGeom = new THREE.SphereGeometry(0.03, 12, 12);
  const footMat = new THREE.MeshStandardMaterial({ color: 0xc44569 });
  const foot1 = new THREE.Mesh(footGeom, footMat); foot1.position.set(-0.06, 0.03, 0.02); foot1.castShadow = true;
  const foot2 = foot1.clone(); foot2.position.x = 0.06;

  const earGeom = new THREE.ConeGeometry(0.02, 0.06, 8);
  const earMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b });
  const ear1 = new THREE.Mesh(earGeom, earMat); ear1.position.set(-0.05,0.35,-0.02); ear1.rotation.z = -0.3; ear1.castShadow = true;
  const ear2 = ear1.clone(); ear2.position.x = 0.05; ear2.rotation.z = 0.3;

  const tail = new THREE.Mesh(new THREE.ConeGeometry(0.02, 0.08, 8), new THREE.MeshStandardMaterial({ color: 0xff6b6b }));
  tail.position.set(0,0.15,-0.1); tail.rotation.x = Math.PI/4; tail.castShadow = true;

  g.add(body, head, eye1, eye2, eyelid1, eyelid2, nose, cheek1, cheek2, foot1, foot2, ear1, ear2, tail);
  return withStandardAnimData(g, { body, head, eyes:[eye1,eye2], eyelids:[eyelid1,eyelid2], ears:[ear1,ear2], tail, feet:[foot1,foot2] });
}

/* --------- Pika-ähnlich ---------- */
function buildPikaLike() {
  const g = new THREE.Group();
  const yellow = 0xffd200;

  const body = new THREE.Mesh(new THREE.SphereGeometry(0.11, 20, 20), new THREE.MeshStandardMaterial({ color: yellow, roughness:0.35 }));
  body.castShadow = true; body.position.y = 0.11;

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.085, 20, 20), new THREE.MeshStandardMaterial({ color: yellow, roughness:0.3 }));
  head.castShadow = true; head.position.set(0,0.27,0);

  const eyeGeom = new THREE.SphereGeometry(0.022, 12, 12);
  const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
  eyeMat.depthWrite = false;
  const eye1 = new THREE.Mesh(eyeGeom, eyeMat); eye1.position.set(-0.03, 0.29, 0.072); eye1.renderOrder = 10;
  const eye2 = eye1.clone(); eye2.position.x = 0.03;

  const eyelidGeom = new THREE.SphereGeometry(0.024, 12, 6, 0, Math.PI*2, 0, Math.PI*0.5);
  const eyelidMat = new THREE.MeshStandardMaterial({ color: yellow });
  eyelidMat.depthWrite = false;
  const eyelid1 = new THREE.Mesh(eyelidGeom, eyelidMat); eyelid1.position.copy(eye1.position); eyelid1.position.y += 0.01; eyelid1.scale.y = 0; eyelid1.renderOrder = 12;
  const eyelid2 = eyelid1.clone(); eyelid2.position.copy(eye2.position); eyelid2.position.y += 0.01;

  const cheekGeom = new THREE.CircleGeometry(0.02, 16);
  const cheekMat = new THREE.MeshStandardMaterial({ color: 0xff4141, transparent:true, opacity:0.9 }); cheekMat.depthWrite = false;
  const cheek1 = new THREE.Mesh(cheekGeom, cheekMat); cheek1.position.set(-0.055,0.255,0.06); cheek1.renderOrder = 11;
  const cheek2 = cheek1.clone(); cheek2.position.x = 0.055;

  const footGeom = new THREE.SphereGeometry(0.028, 12, 12);
  const footMat = new THREE.MeshStandardMaterial({ color: 0xe6b800 });
  const foot1 = new THREE.Mesh(footGeom, footMat); foot1.position.set(-0.055, 0.03, 0.02); foot1.castShadow = true;
  const foot2 = foot1.clone(); foot2.position.x = 0.055;

  const earBaseGeom = new THREE.ConeGeometry(0.018, 0.1, 8);
  const earBlackGeom = new THREE.ConeGeometry(0.017, 0.04, 8);
  const earMat = new THREE.MeshStandardMaterial({ color: yellow });
  const tipMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
  function makeEar(sideSign){
    const e = new THREE.Group();
    const base = new THREE.Mesh(earBaseGeom, earMat);
    const tip = new THREE.Mesh(earBlackGeom, tipMat);
    base.castShadow = true; tip.castShadow = true;
    base.position.y = 0.05; tip.position.y = 0.12;
    e.add(base, tip);
    e.position.set(0.05*sideSign, 0.34, -0.01);
    e.rotation.z = sideSign > 0 ? 0.35 : -0.35;
    return e;
  }
  const ear1 = makeEar(-1);
  const ear2 = makeEar(1);

  const tail = new THREE.Group();
  const tMat = new THREE.MeshStandardMaterial({ color: yellow, metalness:0.05, roughness:0.6 });
  const seg1 = new THREE.Mesh(new THREE.BoxGeometry(0.02,0.06,0.012), tMat);
  const seg2 = new THREE.Mesh(new THREE.BoxGeometry(0.02,0.06,0.012), tMat);
  const seg3 = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.04,0.012), tMat);
  seg1.position.set(0,0.04,0); seg1.rotation.z = Math.PI*0.12;
  seg2.position.set(0.02,0.08,0); seg2.rotation.z = -Math.PI*0.15;
  seg3.position.set(0.055,0.12,0);
  tail.add(seg1, seg2, seg3);
  tail.position.set(-0.02,0.16,-0.1);
  tail.rotation.y = -0.8;

  g.add(body, head, eye1, eye2, eyelid1, eyelid2, cheek1, cheek2, foot1, foot2, ear1, ear2, tail);
  return withStandardAnimData(g, { body, head, eyes:[eye1,eye2], eyelids:[eyelid1,eyelid2], ears:[ear1,ear2], tail, feet:[foot1,foot2] });
}

/* --------- Schiggy-ähnlich (mit Eye-Fix) ---------- */
function buildTurtleLike() {
  const g = new THREE.Group();
  const blue = 0x6ec6ff, shellBrown = 0x8b5a2b, shellRing = 0xf3e2b4;

  const body = new THREE.Mesh(new THREE.SphereGeometry(0.10, 20, 20), new THREE.MeshStandardMaterial({ color: blue, roughness:0.35 }));
  body.castShadow = true; body.position.y = 0.10;

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.085, 20, 20), new THREE.MeshStandardMaterial({ color: blue, roughness:0.3 }));
  head.castShadow = true; head.position.set(0,0.26,0.02);

  // --- EYES: etwas weiter vorne + depthWrite aus + renderOrder hoch ---
  const eyeGeom = new THREE.SphereGeometry(0.022, 12, 12);
  const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
  eyeMat.depthWrite = false;
  const eye1 = new THREE.Mesh(eyeGeom, eyeMat); eye1.position.set(-0.03, 0.285, 0.078); eye1.castShadow = false; eye1.renderOrder = 10;
  const eye2 = eye1.clone(); eye2.position.x = 0.03;

  const eyelidGeom = new THREE.SphereGeometry(0.024, 12, 6, 0, Math.PI*2, 0, Math.PI*0.5);
  const eyelidMat = new THREE.MeshStandardMaterial({ color: blue });
  eyelidMat.depthWrite = false;
  const eyelid1 = new THREE.Mesh(eyelidGeom, eyelidMat); eyelid1.position.copy(eye1.position); eyelid1.position.y += 0.01; eyelid1.scale.y = 0; eyelid1.renderOrder = 12;
  const eyelid2 = eyelid1.clone(); eyelid2.position.copy(eye2.position); eyelid2.position.y += 0.01;

  const shell = new THREE.Group();
  const core = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.11, 0.10, 20), new THREE.MeshStandardMaterial({ color: shellBrown, roughness:0.7 }));
  core.rotation.x = Math.PI/2; core.castShadow = true;
  const ring = new THREE.Mesh(new THREE.TorusGeometry(0.11, 0.015, 10, 24), new THREE.MeshStandardMaterial({ color: shellRing, roughness:0.6 }));
  ring.castShadow = true;
  shell.add(core, ring);
  shell.position.set(0,0.14,-0.02);

  const limbMat = new THREE.MeshStandardMaterial({ color: blue });
  function limb(px, py, pz){
    const m = new THREE.Mesh(new THREE.CapsuleGeometry(0.02, 0.04, 6, 12), limbMat);
    m.position.set(px, py, pz); m.rotation.z = Math.sign(px)*0.4; m.castShadow = true; return m;
  }
  const armL = limb(-0.09, 0.17, 0.02);
  const armR = limb(0.09, 0.17, 0.02);
  const legL = limb(-0.06, 0.04, -0.01);
  const legR = limb(0.06, 0.04, -0.01);

  const ear1 = new THREE.Mesh(new THREE.SphereGeometry(0.012, 8, 8), limbMat); ear1.position.set(-0.045,0.34, -0.02);
  const ear2 = ear1.clone(); ear2.position.x = 0.045;

  const tail = new THREE.Mesh(new THREE.ConeGeometry(0.02, 0.05, 8), new THREE.MeshStandardMaterial({ color: blue }));
  tail.position.set(0,0.15,-0.11); tail.rotation.x = Math.PI/3; tail.castShadow = true;

  g.add(body, head, eye1, eye2, eyelid1, eyelid2, shell, armL, armR, legL, legR, ear1, ear2, tail);
  const feet = [legL, legR];
  return withStandardAnimData(g, { body, head, eyes:[eye1,eye2], eyelids:[eyelid1,eyelid2], ears:[ear1,ear2], tail, feet, footBaseY:0.04 });
}

/* --------- Glumanda-ähnlich ---------- */
function buildLizardLike() {
  const g = new THREE.Group();
  const orange = 0xff8a3d;

  const body = new THREE.Mesh(new THREE.SphereGeometry(0.12, 20, 20), new THREE.MeshStandardMaterial({ color: orange, roughness:0.35 }));
  body.castShadow = true; body.position.y = 0.12;

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.09, 20, 20), new THREE.MeshStandardMaterial({ color: orange, roughness:0.3 }));
  head.castShadow = true; head.position.set(0,0.30,0.01);

  const eyeGeom = new THREE.SphereGeometry(0.024, 12, 12);
  const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
  eyeMat.depthWrite = false;
  const eye1 = new THREE.Mesh(eyeGeom, eyeMat); eye1.position.set(-0.033, 0.31, 0.078); eye1.renderOrder = 10;
  const eye2 = eye1.clone(); eye2.position.x = 0.033;

  const eyelidGeom = new THREE.SphereGeometry(0.026, 12, 6, 0, Math.PI*2, 0, Math.PI*0.5);
  const eyelidMat = new THREE.MeshStandardMaterial({ color: orange });
  eyelidMat.depthWrite = false;
  const eyelid1 = new THREE.Mesh(eyelidGeom, eyelidMat); eyelid1.position.copy(eye1.position); eyelid1.position.y += 0.01; eyelid1.scale.y = 0; eyelid1.renderOrder = 12;
  const eyelid2 = eyelid1.clone(); eyelid2.position.copy(eye2.position); eyelid2.position.y += 0.01;

  const earMat = new THREE.MeshStandardMaterial({ color: orange });
  const ear1 = new THREE.Mesh(new THREE.ConeGeometry(0.018, 0.05, 8), earMat); ear1.position.set(-0.05,0.36,-0.02); ear1.rotation.z = -0.2; ear1.castShadow = true;
  const ear2 = ear1.clone(); ear2.position.x = 0.05; ear2.rotation.z = 0.2;

  const footGeom = new THREE.SphereGeometry(0.03, 12, 12);
  const footMat = new THREE.MeshStandardMaterial({ color: 0xffa766 });
  const foot1 = new THREE.Mesh(footGeom, footMat); foot1.position.set(-0.06, 0.03, 0.02); foot1.castShadow = true;
  const foot2 = foot1.clone(); foot2.position.x = 0.06;

  const tail = new THREE.Group();
  const base = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.11, 10), new THREE.MeshStandardMaterial({ color: orange }));
  base.castShadow = true;
  const flameOuter = new THREE.Mesh(new THREE.SphereGeometry(0.025, 16, 12), new THREE.MeshStandardMaterial({ color: 0xffe08a, emissive:0xff7b00, emissiveIntensity:0.6 }));
  const flameInner = new THREE.Mesh(new THREE.SphereGeometry(0.015, 12, 10), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive:0xffc000, emissiveIntensity:0.8 }));
  base.position.set(0,0.06,0); flameOuter.position.set(0,0.12,0); flameInner.position.set(0,0.12,0);
  tail.add(base, flameOuter, flameInner);
  tail.position.set(0.01,0.16,-0.12); tail.rotation.x = Math.PI/4;

  g.add(body, head, eye1, eye2, eyelid1, eyelid2, ear1, ear2, foot1, foot2, tail);
  return withStandardAnimData(g, { body, head, eyes:[eye1,eye2], eyelids:[eyelid1,eyelid2], ears:[ear1,ear2], tail, feet:[foot1,foot2] });
}

/* --------- Poké-Kugel ---------- */
function buildPokeBall() {
  const group = new THREE.Group();
  const r = 0.06;

  const hemiTop = new THREE.Mesh(
    new THREE.SphereGeometry(r, 24, 16, 0, Math.PI*2, 0, Math.PI/2),
    new THREE.MeshStandardMaterial({ color: 0xd11b1b, metalness:0.2, roughness:0.4 })
  );
  hemiTop.castShadow = true;

  const hemiBot = new THREE.Mesh(
    new THREE.SphereGeometry(r, 24, 16, 0, Math.PI*2, Math.PI/2, Math.PI/2),
    new THREE.MeshStandardMaterial({ color: 0xffffff, metalness:0.05, roughness:0.6 })
  );
  hemiBot.castShadow = true;

  const band = new THREE.Mesh(
    new THREE.TorusGeometry(r*0.72, r*0.08, 10, 32),
    new THREE.MeshStandardMaterial({ color: 0x111111, metalness:0.3, roughness:0.3 })
  );
  band.rotation.x = Math.PI/2;
  band.castShadow = true;

  const buttonOuter = new THREE.Mesh(
    new THREE.CylinderGeometry(r*0.16, r*0.16, r*0.06, 20),
    new THREE.MeshStandardMaterial({ color: 0xeeeeee, metalness:0.1, roughness:0.5 })
  );
  buttonOuter.position.z = r*0.72;
  buttonOuter.rotation.x = Math.PI/2;

  const buttonInner = new THREE.Mesh(
    new THREE.CylinderGeometry(r*0.10, r*0.10, r*0.04, 20),
    new THREE.MeshStandardMaterial({ color: 0x3ac5ff, emissive:0x004466, emissiveIntensity:0.2 })
  );
  buttonInner.position.copy(buttonOuter.position);
  buttonInner.rotation.copy(buttonOuter.rotation);

  group.add(hemiTop, hemiBot, band, buttonOuter, buttonInner);
  group.userData = { spinning:true };
  return group;
}

/* --------- Plane Debug ---------- */
function createPlaneMesh(plane) {
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(plane.polygon.length * 3);
  for (let i=0;i<plane.polygon.length;i++){
    const p = plane.polygon[i];
    positions.set([p.x,p.y,p.z], i*3);
  }
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setIndex([...Array(plane.polygon.length).keys()]);
  const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent:true, opacity: allowPlaneDebug ? 0.25 : 0.0, color: 0xffff00 });
  return new THREE.Mesh(geometry, material);
}
function updatePlaneMesh(mesh, plane) {
  const positions = mesh.geometry.attributes.position.array;
  for (let i=0;i<plane.polygon.length;i++){
    const p = plane.polygon[i];
    positions[i*3]   = p.x;
    positions[i*3+1] = p.y;
    positions[i*3+2] = p.z;
  }
  mesh.geometry.attributes.position.needsUpdate = true;
}
function onPlaneAdded(e){ const mesh = createPlaneMesh(e.plane); planeMeshes.set(e.plane, mesh); scene.add(mesh); lastPlaneSeenAt = performance.now(); }
function onPlaneUpdated(e){ const mesh = planeMeshes.get(e.plane); if (mesh) updatePlaneMesh(mesh, e.plane); lastPlaneSeenAt = performance.now(); }
function onPlaneRemoved(e){ const mesh = planeMeshes.get(e.plane); if (mesh){ scene.remove(mesh); planeMeshes.delete(e.plane); } }

/* --------- UI helpers ---------- */
function showHint(text, timeoutMs=3500){
  const hint = document.getElementById('hint');
  hint.textContent = text;
  hint.classList.remove('hidden');
  if (timeoutMs>0) setTimeout(()=>hint.classList.add('hidden'), timeoutMs);
}
function showActions(show){ document.getElementById('actions').classList.toggle('hidden', !show); }

/* --------- Controller primary (place / jump) ---------- */
function onSelectPrimary() {
  ensureAudio();
  if (reticle.visible || placingMode) {
    const idx = Math.floor(Math.random() * creatureVariants.length);
    creature = creatureVariants[idx];
    for (const g of creatureVariants){ if (g !== creature) g.visible = false; }
    placeCreatureAtReticle();
    SFX.place();
    placingMode = false;
    return;
  }
  if (creature.visible && !isCaptured) {
    triggerJump();
    SFX.jump();
  }
}

/* --------- Controller secondary (capture) ---------- */
function onSelectCapture() {
  ensureAudio();
  if (!creature || !creature.visible || isCaptured || captureState) return;

  const start = new THREE.Vector3();
  controller1.getWorldPosition(start);

  const target = creature.position.clone();
  target.y += 0.55;

  const mid = start.clone().lerp(target, 0.5);
  mid.y += 0.35;

  const groundY = shadowPlane.visible ? shadowPlane.position.y : (creature.position.y - 0.03);

  pokeBall.position.copy(start);
  pokeBall.visible = true;
  pokeBall.scale.set(1,1,1);
  pokeBall.userData.spinning = true;

  captureState = 'fly';
  captureT = 0;
  captureData = { start, mid, target, groundY, velY: 0, duration: 0.6 };
  SFX.throw();
  showHint("Poké-Kugel geworfen!", 1200);
}

/* --------- Platzieren / Entfernen ---------- */
function placeCreatureAtReticle(){
  if (!reticle.visible) { showHint("Kein Ziel gefunden – bewege dich etwas.", 2000); return; }

  const initScale = creature.userData.initialScale ?? 1;
  creature.scale.set(initScale, initScale, initScale);

  creature.position.setFromMatrixPosition(reticle.matrix);
  creature.position.y -= 0.03;
  creature.rotation.set(0, 0, 0);

  creature.userData.animationState = { breathPhase:0, blinkTimer:0, headBobPhase:0, tailWagPhase:0, jumpPhase:0, jumping:false, walkPhase:0 };
  isCaptured = false;
  captureState = null; captureT = 0; captureData = null;

  if (creature.userData.eyelids) for (const lid of creature.userData.eyelids) lid.scale.y = 0;

  shadowPlane.position.copy(creature.position);
  shadowPlane.position.y += 0.002;
  shadowPlane.visible = true;

  creature.visible = true;
  showActions(true);
  showHint("Figur gesetzt. Tipp/Select (Controller 0) lässt sie hüpfen. (Controller 1) wirft die Poké-Kugel.", 2500);
}

function removeCreature(){
  for (const g of creatureVariants) {
    g.visible = false;
    const s = g.userData.initialScale ?? 1;
    g.scale.set(s,s,s);
  }
  shadowPlane.visible = false;

  isCaptured = false;
  captureState = null;
  captureT = 0;
  captureData = null;
  pokeBall.visible = false;

  placingMode = true;
  showActions(false);
  showHint("Figur entfernt. Richte das Reticle aus und platziere neu (zufällige Auswahl).");
}

function triggerJump(){
  const st = creature.userData.animationState;
  if (!st.jumping){ st.jumping = true; st.jumpPhase = 0; }
}

/* --------- Render Loop ---------- */
function render(timestamp, frame) {
  const dt = lastTime ? (timestamp - lastTime) / 1000 : 0;
  lastTime = timestamp;

  if (frame) {
    const session = renderer.xr.getSession();
    const referenceSpace = renderer.xr.getReferenceSpace();

    if (!hitTestSourceRequested) {
      session.requestReferenceSpace('viewer').then((ref) => {
        session.requestHitTestSource({ space: ref }).then((source) => { hitTestSource = source; });
      });
      session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
      hitTestSourceRequested = true;
    }

    if (hitTestSource) {
      const hits = frame.getHitTestResults(hitTestSource);
      if (hits.length > 0) {
        const hit = hits[0];
        const pose = hit.getPose(referenceSpace);
        reticle.visible = true;
        reticle.matrix.fromArray(pose.transform.matrix);
        const s = 1 + Math.sin(timestamp/250) * 0.06;
        reticle.scale.setScalar(s);
        if (reticle.children[0]) (reticle.children[0].material).opacity = 0.15 + Math.abs(Math.sin(timestamp/500))*0.15;
      } else {
        reticle.visible = false;
      }
    }

    if (xrLightProbe) {
      try {
        const estimate = frame.getLightEstimate(xrLightProbe);
        if (estimate && estimate.primaryLightIntensity) {
          const i = estimate.primaryLightIntensity;
          const intensity = Math.min(1.5, Math.max(0.2, (i[0]+i[1]+i[2]) / 3.0 / 1000.0));
          dirLight.intensity = intensity;
          dirLight.position.set(
            estimate.primaryLightDirection.x,
            estimate.primaryLightDirection.y,
            estimate.primaryLightDirection.z
          ).normalize().multiplyScalar(1.2);
          dirLight.color.setRGB(Math.max(0.6,i[0]/1000.0), Math.max(0.6,i[1]/1000.0), Math.max(0.6,i[2]/1000.0));
          hemiLight.intensity = 0.6 + (intensity*0.4);
        }
      } catch {}
    }
  }

  // Creature idle + follow
  if (creature && creature.visible && !isCaptured) {
    const ud = creature.userData;
    const st = ud.animationState;

    const toCam = tmpVec3.subVectors(camera.position, creature.position);
    toCam.y = 0;
    let turnSpeed = 0;
    if (toCam.lengthSq() > 1e-6) {
      const targetYaw = Math.atan2(toCam.x, toCam.z);
      let diff = ((targetYaw - creature.rotation.y + Math.PI) % (Math.PI * 2)) - Math.PI;
      creature.rotation.y = lerpAngle(creature.rotation.y, targetYaw, 0.18);
      turnSpeed = Math.min(1, Math.abs(diff) / 0.4);
    }

    if (ud.feet && ud.feet.length && turnSpeed > 0.05) {
      st.walkPhase += (3.5 + 6.0 * turnSpeed) * dt;
      const amp = 0.012 + 0.01 * turnSpeed;
      const base = ud.footBaseY;
      const liftL = Math.max(0, Math.sin(st.walkPhase));
      const liftR = Math.max(0, Math.sin(st.walkPhase + Math.PI));
      ud.feet[0].position.y = base + liftL * amp;
      ud.feet[1].position.y = base + liftR * amp;
      ud.body.position.y = ud.bodyBaseY + (liftL + liftR) * 0.004;
    } else if (ud.feet && ud.feet.length){
      ud.feet[0].position.y += (ud.footBaseY - ud.feet[0].position.y) * Math.min(1, 8*dt);
      ud.feet[1].position.y += (ud.footBaseY - ud.feet[1].position.y) * Math.min(1, 8*dt);
      ud.body.position.y += (ud.bodyBaseY - ud.body.position.y) * Math.min(1, 8*dt);
    }

    st.breathPhase += 0.02;
    const breathScale = 1 + Math.sin(st.breathPhase) * 0.03;
    ud.body.scale.set(breathScale, breathScale, breathScale);

    st.headBobPhase += 0.015;
    if (ud.head){
      ud.head.rotation.y = Math.sin(st.headBobPhase) * 0.1;
      ud.head.position.y = ud.headBaseY + Math.sin(st.headBobPhase * 1.5) * 0.005;
    }

    st.blinkTimer += 0.016;
    if (st.blinkTimer > 3 + Math.random() * 2 && ud.eyelids) {
      st.blinkTimer = 0;
      ud.eyelids.forEach(eyelid => {
        eyelid.scale.y = 1;
        setTimeout(() => eyelid.scale.y = 0, 140);
      });
    }

    if (ud.ears && ud.ears.length === 2){
      if (Math.sin(st.headBobPhase * 0.7) > 0.95) {
        ud.ears[0].rotation.z = (ud.ears[0].rotation.z ?? -0.3) + Math.sin(timestamp/100) * 0.2;
        ud.ears[1].rotation.z = (ud.ears[1].rotation.z ?? 0.3)  - Math.sin(timestamp/100) * 0.2;
      }
    }

    if (ud.tail){
      st.tailWagPhase += 0.08;
      ud.tail.rotation.x = (ud.tail.rotation.x ?? Math.PI/4) + Math.sin(st.tailWagPhase) * 0.3;
      ud.tail.rotation.y = Math.sin(st.tailWagPhase * 1.2) * 0.4;
    }

    if (st.jumping) {
      st.jumpPhase += 0.12;
      const y = Math.sin(st.jumpPhase) * 0.12;
      creature.position.y = (shadowPlane.position.y + 0.03) + y;
      if (st.jumpPhase >= Math.PI) {
        st.jumping = false; st.jumpPhase = 0;
        creature.position.y = shadowPlane.position.y + 0.03;
      }
      const sc = 1.0 + Math.min(0.15, y * 0.8);
      shadowPlane.scale.setScalar(sc);
    } else {
      shadowPlane.scale.lerp(tmpVec3.set(1,1,1), 0.2);
    }

    shadowPlane.position.x = creature.position.x;
    shadowPlane.position.z = creature.position.z;
  }

  // Poké-Kugel FSM
  if (captureState) {
    const dtLocal = dt;
    pokeBall.rotation.x += dtLocal * 3.0;
    pokeBall.rotation.y += dtLocal * 2.1;

    if (captureState === 'fly') {
      captureT += dtLocal / captureData.duration;
      const t = Math.min(1, captureT);
      const p0 = captureData.start, p1 = captureData.mid, p2 = captureData.target;
      const one = 1 - t;
      pokeBall.position.set(
        one*one*p0.x + 2*one*t*p1.x + t*t*p2.x,
        one*one*p0.y + 2*one*t*p1.y + t*t*p2.y,
        one*one*p0.z + 2*one*t*p1.z + t*t*p2.z
      );
      if (t >= 1) { captureState = 'hover'; captureT = 0; }
    }
    else if (captureState === 'hover') {
      captureT += dtLocal;
      pokeBall.position.y = captureData.target.y + Math.sin(captureT*6.0)*0.02;
      if (captureT > 0.35) { captureState = 'suck'; captureT = 0; SFX.suck(); }
    }
    else if (captureState === 'suck') {
      if (creature && creature.visible) {
        captureT += dtLocal / 0.7;
        const t = Math.min(1, captureT);
        creature.position.lerp(pokeBall.position, 0.18);
        creature.rotation.y += 0.35;
        const s = 1 - t;
        const init = creature.userData.initialScale ?? 1;
        creature.scale.setScalar(Math.max(0, s) * init);
        if (t >= 1) {
          creature.visible = false;
          isCaptured = true;
          showActions(false);
          captureState = 'fall';
          captureT = 0;
          captureData.velY = 0;
        }
      } else {
        captureState = 'fall';
        captureT = 0;
        captureData.velY = 0;
      }
    }
    else if (captureState === 'fall') {
      const g = -2.8;
      captureData.velY += g * dtLocal;
      pokeBall.position.y += captureData.velY * dtLocal;

      if (pokeBall.position.y <= captureData.groundY + 0.03) {
        pokeBall.position.y = captureData.groundY + 0.03;
        if (Math.abs(captureData.velY) > 0.6) {
          captureData.velY *= -0.35;
          SFX.bounce();
        } else {
          pokeBall.visible = false;
          captureState = null;
          captureT = 0;
          captureData = null;
          placingMode = true;
          showHint("Gefangen! Setze die Figur neu aus (Controller 0 + Reticle).", 2500);
        }
      }
    }
  }

  if (allowPlaneDebug && performance.now() - lastPlaneSeenAt > 5000) {
    allowPlaneDebug = false;
    document.getElementById('legend')?.classList.add('hidden');
    planeMeshes.forEach(m => m.material.opacity = 0.0);
  }

  renderer.render(scene, camera);
}

/* ---------- Plane events ---------- */
function onPlaneAdded(e){ const mesh = createPlaneMesh(e.plane); planeMeshes.set(e.plane, mesh); scene.add(mesh); lastPlaneSeenAt = performance.now(); }
function onPlaneUpdated(e){ const mesh = planeMeshes.get(e.plane); if (mesh) updatePlaneMesh(mesh, e.plane); lastPlaneSeenAt = performance.now(); }
function onPlaneRemoved(e){ const mesh = planeMeshes.get(e.plane); if (mesh){ scene.remove(mesh); planeMeshes.delete(e.plane); } }

</script>
</body>
</html>
