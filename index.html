<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <title>WebXR AR Plane Detection Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { ARButton } from 'https://unpkg.com/three@0.152.2/examples/jsm/webxr/ARButton.js';

let camera, scene, renderer;
let controller;
let reticle;
let creature;
let hitTestSource = null;
let hitTestSourceRequested = false;
const planeMeshes = new Map();

init();

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Plane-Detection Feature anfordern
    const btn = ARButton.createButton(renderer, {
        requiredFeatures: ['hit-test', 'plane-detection'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.body }
    });
    document.body.appendChild(btn);

    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
    scene.add(light);

    // Reticle für Platzierung
    reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Pokemon-ähnliche Kreatur
    creature = new THREE.Group();
    
    // Körper (größer und rundlicher)
    const body = new THREE.Mesh(
        new THREE.SphereGeometry(0.12, 20, 20),
        new THREE.MeshStandardMaterial({ 
            color: 0xff6b6b,
            roughness: 0.3,
            metalness: 0.1
        })
    );
    body.position.y = 0.12; // Höher positionieren
    
    // Kopf (größer und expressiver)
    const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 20, 20),
        new THREE.MeshStandardMaterial({ 
            color: 0xff8e8e,
            roughness: 0.2,
            metalness: 0.1
        })
    );
    head.position.set(0, 0.28, 0); // Höher positionieren
    
    // Augen (größer und lebendiger)
    const eyeGeometry = new THREE.SphereGeometry(0.025, 12, 12);
    const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
    const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
    eye1.position.set(-0.03, 0.3, 0.07);
    const eye2 = eye1.clone();
    eye2.position.x = 0.03;
    
    // Augenlider für Blinzeln
    const eyelidGeometry = new THREE.SphereGeometry(0.026, 12, 6, 0, Math.PI * 2, 0, Math.PI * 0.5);
    const eyelidMaterial = new THREE.MeshStandardMaterial({ color: 0xff8e8e });
    const eyelid1 = new THREE.Mesh(eyelidGeometry, eyelidMaterial);
    eyelid1.position.copy(eye1.position);
    eyelid1.position.y += 0.01;
    eyelid1.scale.y = 0;
    const eyelid2 = eyelid1.clone();
    eyelid2.position.copy(eye2.position);
    eyelid2.position.y += 0.01;
    
    // Nase/Schnauze
    const nose = new THREE.Mesh(
        new THREE.ConeGeometry(0.015, 0.03, 8),
        new THREE.MeshStandardMaterial({ color: 0xff4757 })
    );
    nose.position.set(0, 0.28, 0.08);
    nose.rotation.x = Math.PI / 2;
    
    // Wangen (rote Kreise)
    const cheekGeometry = new THREE.CircleGeometry(0.02, 16);
    const cheekMaterial = new THREE.MeshStandardMaterial({ color: 0xff3838, transparent: true, opacity: 0.8 });
    const cheek1 = new THREE.Mesh(cheekGeometry, cheekMaterial);
    cheek1.position.set(-0.06, 0.26, 0.06);
    const cheek2 = cheek1.clone();
    cheek2.position.x = 0.06;
    
    // Füße (rundlicher und süßer)
    const footGeometry = new THREE.SphereGeometry(0.03, 12, 12);
    const footMaterial = new THREE.MeshStandardMaterial({ color: 0xc44569 });
    const foot1 = new THREE.Mesh(footGeometry, footMaterial);
    foot1.position.set(-0.06, 0.03, 0.02); // Höher positionieren
    const foot2 = foot1.clone();
    foot2.position.x = 0.06;
    
    // Ohren
    const earGeometry = new THREE.ConeGeometry(0.02, 0.06, 8);
    const earMaterial = new THREE.MeshStandardMaterial({ color: 0xff6b6b });
    const ear1 = new THREE.Mesh(earGeometry, earMaterial);
    ear1.position.set(-0.05, 0.35, -0.02);
    ear1.rotation.z = -0.3;
    const ear2 = ear1.clone();
    ear2.position.x = 0.05;
    ear2.rotation.z = 0.3;
    
    // Schwanz
    const tail = new THREE.Mesh(
        new THREE.ConeGeometry(0.02, 0.08, 8),
        new THREE.MeshStandardMaterial({ color: 0xff6b6b })
    );
    tail.position.set(0, 0.15, -0.1);
    tail.rotation.x = Math.PI / 4;
    
    creature.add(body, head, eye1, eye2, eyelid1, eyelid2, nose, cheek1, cheek2, foot1, foot2, ear1, ear2, tail);
    
    // Referenzen für Animation speichern
    creature.userData = {
        body: body,
        head: head,
        eyes: [eye1, eye2],
        eyelids: [eyelid1, eyelid2],
        ears: [ear1, ear2],
        tail: tail,
        animationState: {
            breathPhase: 0,
            blinkTimer: 0,
            headBobPhase: 0,
            tailWagPhase: 0
        }
    };
    creature.visible = false;
    scene.add(creature);

    controller = renderer.xr.getController(0);
    controller.addEventListener('select', onSelect);
    scene.add(controller);

    renderer.xr.addEventListener('sessionstart', () => {
        const session = renderer.xr.getSession();
        // Plane Detection aktivieren
        session.updateWorldTrackingState({ planeDetectionState: { enabled: true } });
        session.addEventListener('planeadded', onPlaneAdded);
        session.addEventListener('planeremoved', onPlaneRemoved);
        session.addEventListener('planeupdated', onPlaneUpdated);
    });

    window.addEventListener('resize', onWindowResize);
    renderer.setAnimationLoop(render);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function onSelect() {
    if (reticle.visible) {
        creature.position.setFromMatrixPosition(reticle.matrix);
        // Kreatur direkt auf Bodenhöhe positionieren (Füße berühren Boden)
        creature.position.y -= 0.03; // Leicht nach unten, damit Füße den Boden berühren
        creature.visible = true;
    }
}

function onPlaneAdded(event) {
    const plane = event.plane;
    const mesh = createPlaneMesh(plane);
    planeMeshes.set(plane, mesh);
    scene.add(mesh);
}

function onPlaneUpdated(event) {
    const plane = event.plane;
    const mesh = planeMeshes.get(plane);
    if (mesh) updatePlaneMesh(mesh, plane);
}

function onPlaneRemoved(event) {
    const plane = event.plane;
    const mesh = planeMeshes.get(plane);
    if (mesh) {
        scene.remove(mesh);
        planeMeshes.delete(plane);
    }
}

function createPlaneMesh(plane) {
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(plane.polygon.length * 3);
    for (let i = 0; i < plane.polygon.length; i++) {
        const p = plane.polygon[i];
        positions.set([p.x, p.y, p.z], i * 3);
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setIndex([...Array(plane.polygon.length).keys()]);
    geometry.computeVertexNormals();
    const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true, opacity: 0.3, color: 0xffff00 });
    const mesh = new THREE.Mesh(geometry, material);
    return mesh;
}

function updatePlaneMesh(mesh, plane) {
    const positions = mesh.geometry.attributes.position.array;
    for (let i = 0; i < plane.polygon.length; i++) {
        const p = plane.polygon[i];
        positions[i * 3] = p.x;
        positions[i * 3 + 1] = p.y;
        positions[i * 3 + 2] = p.z;
    }
    mesh.geometry.attributes.position.needsUpdate = true;
}

function render(timestamp, frame) {
    if (frame) {
        const session = renderer.xr.getSession();
        const referenceSpace = renderer.xr.getReferenceSpace();

        if (!hitTestSourceRequested) {
            session.requestReferenceSpace('viewer').then((ref) => {
                session.requestHitTestSource({ space: ref }).then((source) => { hitTestSource = source; });
            });
            session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
            hitTestSourceRequested = true;
        }

        if (hitTestSource) {
            const hits = frame.getHitTestResults(hitTestSource);
            if (hits.length > 0) {
                const hit = hits[0];
                const pose = hit.getPose(referenceSpace);
                reticle.visible = true;
                reticle.matrix.fromArray(pose.transform.matrix);
            } else {
                reticle.visible = false;
            }
        }
    }

    if (creature.visible) {
        const t = timestamp / 1000;
        const userData = creature.userData;
        const animState = userData.animationState;
        
        // Atmungsanimation
        animState.breathPhase += 0.02;
        const breathScale = 1 + Math.sin(animState.breathPhase) * 0.03;
        userData.body.scale.set(breathScale, breathScale, breathScale);
        
        // Kopfwackeln (subtil)
        animState.headBobPhase += 0.015;
        userData.head.rotation.y = Math.sin(animState.headBobPhase) * 0.1;
        userData.head.position.y = 0.28 + Math.sin(animState.headBobPhase * 1.5) * 0.005;
        
        // Blinzeln
        animState.blinkTimer += 0.016;
        if (animState.blinkTimer > 3 + Math.random() * 2) { // Alle 3-5 Sekunden blinzeln
            animState.blinkTimer = 0;
            // Kurzes Blinzeln
            userData.eyelids.forEach(eyelid => {
                eyelid.scale.y = 1;
                setTimeout(() => eyelid.scale.y = 0, 150);
            });
        }
        
        // Ohren wackeln gelegentlich
        if (Math.sin(animState.headBobPhase * 0.7) > 0.95) {
            userData.ears[0].rotation.z = -0.3 + Math.sin(t * 15) * 0.2;
            userData.ears[1].rotation.z = 0.3 - Math.sin(t * 15) * 0.2;
        } else {
            userData.ears[0].rotation.z = -0.3;
            userData.ears[1].rotation.z = 0.3;
        }
        
        // Schwanzwedeln
        animState.tailWagPhase += 0.08;
        userData.tail.rotation.x = Math.PI / 4 + Math.sin(animState.tailWagPhase) * 0.3;
        userData.tail.rotation.y = Math.sin(animState.tailWagPhase * 1.2) * 0.4;
    }

    renderer.render(scene, camera);
}
</script>
</body>
</html>
