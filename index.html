<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>WebXR AR Plane Detection Demo – Plus</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:transparent; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    #ui {
      position:fixed; inset:0; pointer-events:none;
      display:flex; align-items:flex-end; justify-content:center;
      padding:16px;
    }
    .hint {
      pointer-events:auto;
      background:rgba(0,0,0,.55);
      color:#fff;
      padding:10px 12px; border-radius:12px; font-size:14px;
      backdrop-filter: blur(6px);
      max-width:min(90vw,720px);
    }
    .actions {
      position:fixed; top:12px; right:12px; display:flex; gap:8px; pointer-events:auto;
    }
    .btn {
      border:0; border-radius:10px; padding:8px 12px; font-size:14px; cursor:pointer;
      background:#111; color:#fff; opacity:.9;
    }
    .btn:active { transform: translateY(1px); }
    .hidden { display:none !important; }
    /* dezente plane-visualisierung */
    .legend {
      position:fixed; left:12px; bottom:12px; font-size:12px; color:#fff; opacity:.75; pointer-events:auto;
      background:rgba(0,0,0,.45); padding:6px 8px; border-radius:8px;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="hint" class="hint">
      Bewege das Headset/Smartphone, bis Flächen erkannt sind. <b>Tippe/Select</b> zum Platzieren. 
      Tippe auf die Figur, um sie hüpfen zu lassen. <b>Reticle sichtbar + Select</b> = neu platzieren.
    </div>
  </div>
  <div class="actions hidden" id="actions">
    <button class="btn" id="reposition">Neu platzieren</button>
    <button class="btn" id="remove">Entfernen</button>
  </div>
  <div class="legend" id="legend">Gelbe Flächen = erkannte Ebenen (blenden nach kurzer Zeit aus)</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { ARButton } from 'https://unpkg.com/three@0.152.2/examples/jsm/webxr/ARButton.js';

let camera, scene, renderer;
let controller;
let reticle;
let creature, shadowPlane;
let hitTestSource = null;
let hitTestSourceRequested = false;
const planeMeshes = new Map();

let dirLight, hemiLight;
let xrLightProbe = null, xrGlBinding = null; // Light Estimation (optional)
let allowPlaneDebug = true;
let lastPlaneSeenAt = 0;
let placingMode = true; // wenn true, Select platziert statt zu interagieren
const tmpVec3 = new THREE.Vector3();

init();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  const btn = ARButton.createButton(renderer, {
    requiredFeatures: ['hit-test', 'plane-detection'],
    optionalFeatures: ['dom-overlay','light-estimation'],
    domOverlay: { root: document.body }
  });
  document.body.appendChild(btn);

  // Beleuchtung
  hemiLight = new THREE.HemisphereLight(0xffffff, 0x666688, 0.9);
  scene.add(hemiLight);

  dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(0.5, 1.2, 0.5);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(1024,1024);
  dirLight.shadow.camera.near = 0.01;
  dirLight.shadow.camera.far = 5;
  dirLight.shadow.radius = 2;
  scene.add(dirLight);

  // Reticle
  reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.12, 0.18, 40).rotateX(-Math.PI / 2),
    new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent:true, opacity:0.9 })
  );
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // pulsierende Reticle-Scheibe innen
  const inner = new THREE.Mesh(
    new THREE.CircleGeometry(0.12, 32).rotateX(-Math.PI/2),
    new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent:true, opacity:0.15 })
  );
  reticle.add(inner);

  // Kreatur
  creature = buildCreature();
  creature.visible = false;
  scene.add(creature);

  // Kontakt-Schattenfläche
  shadowPlane = new THREE.Mesh(
    new THREE.CircleGeometry(0.16, 32).rotateX(-Math.PI/2),
    new THREE.ShadowMaterial({ opacity: 0.35 })
  );
  shadowPlane.receiveShadow = true;
  shadowPlane.visible = false;
  scene.add(shadowPlane);

  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelect);
  scene.add(controller);

  renderer.xr.addEventListener('sessionstart', onSessionStart);
  window.addEventListener('resize', onWindowResize);

  // UI
  document.getElementById('reposition').onclick = () => { placingMode = true; showHint("Ziel anvisieren & Select drücken, um neu zu platzieren."); };
  document.getElementById('remove').onclick = () => removeCreature();

  renderer.setAnimationLoop(render);
}

function onSessionStart() {
  const session = renderer.xr.getSession();
  // Plane Detection Events
  session.updateWorldTrackingState({ planeDetectionState: { enabled: true } });
  session.addEventListener('planeadded', onPlaneAdded);
  session.addEventListener('planeremoved', onPlaneRemoved);
  session.addEventListener('planeupdated', onPlaneUpdated);

  // Light Estimation (optional, sicher abgefangen)
  try {
    if (session.requestLightProbe) {
      xrGlBinding = new XRWebGLBinding(session, renderer.getContext());
      session.requestLightProbe({ /* reflectionFormat:'srgba8' */ }).then(lp => {
        xrLightProbe = lp;
        // kleine Bestätigung im Hint
        // showHint("Light Estimation aktiv – Beleuchtung passt sich an.");
      }).catch(()=>{ xrLightProbe = null; });
    }
  } catch { xrLightProbe = null; }

  showHint("Bewegen, bis Flächen erkannt sind. Select/Tippen zum Platzieren.");
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/* --------- Creature ---------- */
function buildCreature() {
  const g = new THREE.Group();

  const body = new THREE.Mesh(
    new THREE.SphereGeometry(0.12, 20, 20),
    new THREE.MeshStandardMaterial({ color: 0xff6b6b, roughness:0.35, metalness:0.05 })
  );
  body.castShadow = true; body.receiveShadow = false;
  body.position.y = 0.12;

  const head = new THREE.Mesh(
    new THREE.SphereGeometry(0.08, 20, 20),
    new THREE.MeshStandardMaterial({ color: 0xff8e8e, roughness:0.25, metalness:0.1 })
  );
  head.castShadow = true; head.position.set(0,0.28,0);

  const eyeGeom = new THREE.SphereGeometry(0.025, 12, 12);
  const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness:0.4, metalness:0.3 });
  const eye1 = new THREE.Mesh(eyeGeom, eyeMat); eye1.position.set(-0.03, 0.3, 0.07); eye1.castShadow = true;
  const eye2 = eye1.clone(); eye2.position.x = 0.03;

  const eyelidGeom = new THREE.SphereGeometry(0.026, 12, 6, 0, Math.PI * 2, 0, Math.PI * 0.5);
  const eyelidMat = new THREE.MeshStandardMaterial({ color: 0xff8e8e });
  const eyelid1 = new THREE.Mesh(eyelidGeom, eyelidMat); eyelid1.position.copy(eye1.position); eyelid1.position.y += 0.01; eyelid1.scale.y = 0;
  const eyelid2 = eyelid1.clone(); eyelid2.position.copy(eye2.position); eyelid2.position.y += 0.01;

  const nose = new THREE.Mesh(new THREE.ConeGeometry(0.015, 0.03, 8), new THREE.MeshStandardMaterial({ color: 0xff4757 }));
  nose.position.set(0,0.28,0.08); nose.rotation.x = Math.PI/2; nose.castShadow = true;

  const cheekGeom = new THREE.CircleGeometry(0.02, 16);
  const cheekMat = new THREE.MeshStandardMaterial({ color: 0xff3838, transparent:true, opacity:0.8 });
  const cheek1 = new THREE.Mesh(cheekGeom, cheekMat); cheek1.position.set(-0.06,0.26,0.06);
  const cheek2 = cheek1.clone(); cheek2.position.x = 0.06;

  const footGeom = new THREE.SphereGeometry(0.03, 12, 12);
  const footMat = new THREE.MeshStandardMaterial({ color: 0xc44569 });
  const foot1 = new THREE.Mesh(footGeom, footMat); foot1.position.set(-0.06, 0.03, 0.02); foot1.castShadow = true;
  const foot2 = foot1.clone(); foot2.position.x = 0.06;

  const earGeom = new THREE.ConeGeometry(0.02, 0.06, 8);
  const earMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b });
  const ear1 = new THREE.Mesh(earGeom, earMat); ear1.position.set(-0.05,0.35,-0.02); ear1.rotation.z = -0.3; ear1.castShadow = true;
  const ear2 = ear1.clone(); ear2.position.x = 0.05; ear2.rotation.z = 0.3;

  const tail = new THREE.Mesh(new THREE.ConeGeometry(0.02, 0.08, 8), new THREE.MeshStandardMaterial({ color: 0xff6b6b }));
  tail.position.set(0,0.15,-0.1); tail.rotation.x = Math.PI/4; tail.castShadow = true;

  g.add(body, head, eye1, eye2, eyelid1, eyelid2, nose, cheek1, cheek2, foot1, foot2, ear1, ear2, tail);

  g.userData = {
    body, head, eyes:[eye1,eye2], eyelids:[eyelid1,eyelid2], ears:[ear1,ear2], tail,
    animationState: { breathPhase:0, blinkTimer:0, headBobPhase:0, tailWagPhase:0, jumpPhase:0, jumping:false }
  };
  return g;
}

/* --------- Plane Debug Mesh ---------- */
function createPlaneMesh(plane) {
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(plane.polygon.length * 3);
  for (let i=0;i<plane.polygon.length;i++){
    const p = plane.polygon[i];
    positions.set([p.x,p.y,p.z], i*3);
  }
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setIndex([...Array(plane.polygon.length).keys()]);
  const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent:true, opacity: allowPlaneDebug ? 0.25 : 0.0, color: 0xffff00 });
  const mesh = new THREE.Mesh(geometry, material);
  return mesh;
}
function updatePlaneMesh(mesh, plane) {
  const positions = mesh.geometry.attributes.position.array;
  for (let i=0;i<plane.polygon.length;i++){
    const p = plane.polygon[i];
    positions[i*3]   = p.x;
    positions[i*3+1] = p.y;
    positions[i*3+2] = p.z;
  }
  mesh.geometry.attributes.position.needsUpdate = true;
}

/* --------- Events ---------- */
function onPlaneAdded(e){ 
  const mesh = createPlaneMesh(e.plane);
  planeMeshes.set(e.plane, mesh);
  scene.add(mesh);
  lastPlaneSeenAt = performance.now();
}
function onPlaneUpdated(e){ 
  const mesh = planeMeshes.get(e.plane);
  if (mesh) updatePlaneMesh(mesh, e.plane);
  lastPlaneSeenAt = performance.now();
}
function onPlaneRemoved(e){
  const mesh = planeMeshes.get(e.plane);
  if (mesh){ scene.remove(mesh); planeMeshes.delete(e.plane); }
}

/* --------- UI helpers ---------- */
function showHint(text, timeoutMs=3500){
  const hint = document.getElementById('hint');
  hint.textContent = text;
  hint.classList.remove('hidden');
  if (timeoutMs>0) setTimeout(()=>hint.classList.add('hidden'), timeoutMs);
}
function showActions(show){
  document.getElementById('actions').classList.toggle('hidden', !show);
}

/* --------- Placement / Interaction ---------- */
function onSelect() {
  // Wenn Reticle sichtbar ODER wir explizit im Placing-Mode sind: platzieren/neu platzieren
  if (reticle.visible || placingMode) {
    placeCreatureAtReticle();
    placingMode = false;
    return;
  }
  // sonst: Interaktion (Hüpfen)
  if (creature.visible) triggerJump();
}

function placeCreatureAtReticle(){
  if (!reticle.visible) { showHint("Kein Ziel gefunden – bewege dich etwas.", 2000); return; }
  creature.position.setFromMatrixPosition(reticle.matrix);
  // Füße auf Boden
  creature.position.y -= 0.03;

  // zur Kamera drehen (leicht)
  creature.lookAt(camera.position);
  creature.rotation.y += Math.PI; // nach vorne schauen

  // Schatten-Plane unter die Figur
  shadowPlane.position.copy(creature.position);
  shadowPlane.position.y += 0.002; // ganz knapp über Boden
  shadowPlane.visible = true;

  creature.visible = true;
  showActions(true);
  showHint("Tippe auf die Figur, um sie hüpfen zu lassen.", 2500);
}

function removeCreature(){
  creature.visible = false;
  shadowPlane.visible = false;
  placingMode = true;
  showActions(false);
  showHint("Figur entfernt. Richte das Reticle aus und platziere neu.");
}

function triggerJump(){
  const st = creature.userData.animationState;
  if (!st.jumping){
    st.jumping = true;
    st.jumpPhase = 0;
  }
}

/* --------- Render Loop ---------- */
function render(timestamp, frame) {
  // Hit-Test
  if (frame) {
    const session = renderer.xr.getSession();
    const referenceSpace = renderer.xr.getReferenceSpace();

    if (!hitTestSourceRequested) {
      session.requestReferenceSpace('viewer').then((ref) => {
        session.requestHitTestSource({ space: ref }).then((source) => { hitTestSource = source; });
      });
      session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
      hitTestSourceRequested = true;
    }

    if (hitTestSource) {
      const hits = frame.getHitTestResults(hitTestSource);
      const hasHit = hits.length > 0;
      if (hasHit) {
        const hit = hits[0];
        const pose = hit.getPose(referenceSpace);
        reticle.visible = true;
        reticle.matrix.fromArray(pose.transform.matrix);

        // Reticle: sanft pulsieren + feedback-farbe
        const s = 1 + Math.sin(timestamp/250) * 0.06;
        reticle.scale.setScalar(s);
        (reticle.material).color.setHex(0x00ff88);
        if (reticle.children[0]) (reticle.children[0].material).opacity = 0.15 + Math.abs(Math.sin(timestamp/500))*0.15;

      } else {
        reticle.visible = false;
      }
    }

    // Light Estimation
    if (xrLightProbe) {
      try {
        const estimate = frame.getLightEstimate(xrLightProbe);
        if (estimate && estimate.primaryLightIntensity) {
          // primaryLightIntensity ist ein Float32Array[3] (RGB) im Bereich ~Lumen; wir normalisieren grob
          const i = estimate.primaryLightIntensity;
          const intensity = Math.min(1.5, Math.max(0.2, (i[0]+i[1]+i[2]) / 3.0 / 1000.0));
          dirLight.intensity = intensity;
          dirLight.position.set(
            estimate.primaryLightDirection.x,
            estimate.primaryLightDirection.y,
            estimate.primaryLightDirection.z
          ).normalize().multiplyScalar(1.2);
          // grob die Farbe setzen
          dirLight.color.setRGB(Math.max(0.6,i[0]/1000.0), Math.max(0.6,i[1]/1000.0), Math.max(0.6,i[2]/1000.0));
          hemiLight.intensity = 0.6 + (intensity*0.4);
        }
      } catch { /* ignorieren, falls nicht unterstützt */ }
    }
  }

  // Creature Animation
  if (creature.visible) {
    const t = timestamp / 1000;
    const ud = creature.userData;
    const st = ud.animationState;

    // Atmung
    st.breathPhase += 0.02;
    const breathScale = 1 + Math.sin(st.breathPhase) * 0.03;
    ud.body.scale.set(breathScale, breathScale, breathScale);

    // Kopf idle
    st.headBobPhase += 0.015;
    ud.head.rotation.y = Math.sin(st.headBobPhase) * 0.1;
    ud.head.position.y = 0.28 + Math.sin(st.headBobPhase * 1.5) * 0.005;

    // Blinzeln
    st.blinkTimer += 0.016;
    if (st.blinkTimer > 3 + Math.random() * 2) {
      st.blinkTimer = 0;
      ud.eyelids.forEach(eyelid => {
        eyelid.scale.y = 1;
        setTimeout(() => eyelid.scale.y = 0, 140);
      });
    }

    // Ohren
    if (Math.sin(st.headBobPhase * 0.7) > 0.95) {
      ud.ears[0].rotation.z = -0.3 + Math.sin(t * 15) * 0.2;
      ud.ears[1].rotation.z = 0.3 - Math.sin(t * 15) * 0.2;
    } else {
      ud.ears[0].rotation.z = -0.3;
      ud.ears[1].rotation.z = 0.3;
    }

    // Schwanz
    st.tailWagPhase += 0.08;
    ud.tail.rotation.x = Math.PI/4 + Math.sin(st.tailWagPhase) * 0.3;
    ud.tail.rotation.y = Math.sin(st.tailWagPhase * 1.2) * 0.4;

    // Jump
    if (st.jumping) {
      st.jumpPhase += 0.12;
      const y = Math.sin(st.jumpPhase) * 0.12; // Sprunghöhe
      creature.position.y = (shadowPlane.position.y + 0.03) + y;
      // Landung beendet
      if (st.jumpPhase >= Math.PI) {
        st.jumping = false; st.jumpPhase = 0;
        creature.position.y = shadowPlane.position.y + 0.03;
      }
      // Schatten leicht skalieren
      const sc = 1.0 + Math.min(0.15, y * 0.8);
      shadowPlane.scale.setScalar(sc);
    } else {
      // Schatten normalisieren
      shadowPlane.scale.lerp(tmpVec3.set(1,1,1), 0.2);
    }

    // Schatten-Plane der Figur folgen (bei kleiner Bewegung / Neupositionierung)
    shadowPlane.position.x = creature.position.x;
    shadowPlane.position.z = creature.position.z;
  }

  // Plane-Overlays nach 5s ohne Update ausblenden
  if (allowPlaneDebug && performance.now() - lastPlaneSeenAt > 5000) {
    allowPlaneDebug = false;
    document.getElementById('legend')?.classList.add('hidden');
    planeMeshes.forEach(m => m.material.opacity = 0.0);
  }

  renderer.render(scene, camera);
}
</script>
</body>
</html>
